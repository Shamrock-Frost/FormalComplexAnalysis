import .complex .algebra .macros .sets

theorem problem16
  : ∀ (a z : ℂ), |z| = 1 → 1 - (complex.conj a)*z ≠ 0
               → |z - a|/|1 - (complex.conj a) * z| = 1 :=
begin
  intros a z h1' h2, have h1 := eq_one_of_sqrt_eq_one h1',
  suffices : complex.norm (z - a)
           = complex.norm (1 - (complex.conj a) * z),
  { rw div_eq_one_iff_eq, assumption, 
    revert h2, apply mt, intro h2,
    apply norm_zero_implies_zero, assumption, },
  apply congr_arg sqrt,
  cases z with x y, simp [complex.norm_squared] at h1,
  cases a with a b,
  simp [complex.conj],
  transitivity (x - a)*(x - a) + (y - b)*(y - b), refl,
  transitivity (1-a*x - b*y)*(1-a*x - b*y) + (-a*y + b*x)*(-a*y + b*x),
  { rw ← sub_add_eq_sub_sub,
    rw FOIL, rw (_ : -a * y * (-a * y) = (a*a)*(y*y)),
    rw (_ : b*x*(b*x) = (b*b)*(x*x)),
    rw sub_eq_add_neg (1 : ℝ), rw FOIL,
    rw mul_one, rw mul_one, rw one_mul,
    rw neg_mul_neg, rw FOIL,
    rw (_ : a * x * (a * x) = a * a * (x * x)),
    rw (_ : b * y * (b * y) = b * b * (y * y)),
    rw add_assoc,
    rw (_ : (a * a * (x * x) + a * x * (b * y) + b * y * (a * x) + b * b * (y * y))
          + (a * a * (y * y) + -a * y * (b * x) + b * x * (-a * y) + b * b * (x * x))
          = ((a * a * (x * x) + a * a * (y * y)) + a * x * (b * y) + b * y * (a * x))
          + (-a * y * (b * x) + b * x * (-a * y) + (b * b * (x * x) + b * b * (y * y)))),
    tactic.swap,
    { repeat { rw add_assoc }, apply congr_arg,
      repeat { rw ← add_left_comm ((a*a)*(y*y)) }, repeat { apply congr_arg },
      repeat { rw add_left_comm ((b*b)*(y*y)) }, repeat { apply congr_arg },
      apply add_comm }, 
    rw [← left_distrib (a*a) (x*x) (y*y), ← left_distrib (b*b) (x*x) (y*y)],
    rw [h1, mul_one, mul_one], 
    rw [add_assoc, add_assoc, add_assoc, add_assoc, add_assoc],
    repeat { rw ← add_left_comm (a*a) },
    rw add_comm _ (b*b),
    repeat { rw ← add_left_comm (b*b) },
    rw [← add_assoc, ← add_assoc],
    rw [FOIL_neg_square, FOIL_neg_square],
    transitivity b * b + a * a + (x * x + y*y) + ((-(x * a) + -(x * a)) + (-(y * b) + -(y * b))),
    { generalize : -(x * a) = u, generalize : -(y * b) = v, ac_refl },
    apply congr, { congr, assumption },
    rw neg_add, rw mul_comm a x, rw mul_comm b y,
    generalize hu : -(x * a) = u,
    generalize hv : -(y * b) = v,
    rw add_assoc, rw add_assoc, rw add_assoc, 
    rw add_left_comm u v v,
    transitivity u + (v + (u + (v + 0))), rw add_zero,
    congr, transitivity a * b * x * y + (a * b * x * y + (-(a * b * x * y) + -(a * b * x * y))),
    rw [← add_assoc, ← neg_add, add_neg_self],
    apply congr, { apply congr_arg, ac_refl },
    apply congr, { apply congr_arg, ac_refl },
    apply congr, { apply congr_arg, tactic.unwrap_neg, ac_refl },
    { tactic.unwrap_neg, ac_refl },
    ac_refl, ac_refl, ac_refl, 
    rw [mul_left_comm, mul_assoc, ← mul_assoc, neg_mul_neg] },
  { rw (_ : 1 = complex.mk 1 0), simp,
    simp [complex.norm_squared], refl },
end

-- a set of complex numbers is a circle if it is a set of points
-- a fixed distance from some other point
def mk_circle (center : ℂ) (radius : ℝ) := { z : ℂ | |z - center| = radius }
def is_circle (S : set ℂ) := ∃ center radius, S = mk_circle center radius

lemma shift_sends_circles_to_circles
  : ∀ r z₀ c, fun.im (λ z, z - c) (mk_circle z₀ r)
            = mk_circle (z₀ - c) r :=
begin
  intros, funext, apply propext,
  suffices : (∃w, |w - z₀| = r ∧ b = w - c) ↔ |b - (z₀ - c)| = r, exact this,
  constructor; intro h,
  { cases h with w h, cases h with hdist hb,
    rw hb, rw [sub_eq_add_neg _ c, sub_eq_add_neg _ c],
    rw add_sub_add_right_eq_sub, assumption },
  { rw [sub_eq_add_neg, neg_sub, ← add_sub_assoc] at h,
    existsi b + c, constructor, assumption, rw add_sub_cancel }
end

noncomputable def center_of_inverted_circle (r : ℝ) (z₀ : ℂ) : ℂ :=
  complex.conj (complex.scalar_mul (1 / (complex.norm_squared z₀ - r * r)) z₀)

noncomputable def radius_of_inverted_circle (r : ℝ) (z₀ : ℂ) : ℝ :=
  √(complex.norm_squared (center_of_inverted_circle r z₀) - 1 / (complex.norm_squared z₀ - r * r))

lemma random_inversion_inequality
  (z₀ : ℂ) (r : ℝ) (h1 : r ≠ |z₀| ) (h2 : 0 < r) : 1 / (complex.norm_squared z₀ - r * r) ≤
    complex.norm_squared (complex.conj (complex.scalar_mul (1 / (complex.norm_squared z₀ - r * r)) z₀)) :=
begin
  rw (_ : complex.norm_squared (complex.conj (complex.scalar_mul (1 / (complex.norm_squared z₀ - r * r)) z₀))
          = complex.norm_squared z₀/(abs(complex.norm_squared z₀ - r*r)*abs(complex.norm_squared z₀ - r*r))),
  apply le_div_of_mul_le,
  have h2 : abs (complex.norm_squared z₀ - r * r) > 0,
  { apply lt_of_le_of_ne, apply abs_nonneg,
    apply ne.symm, apply mt eq_zero_of_abs_eq_zero,
    apply mt eq_of_sub_eq_zero, rw ← squared_norm_eq_norm_squared,
    apply mt (eq_of_nonneg_and_sq_eq _ _), apply ne.symm, assumption,
    apply complex.norm_nonneg, apply le_of_lt, assumption, },
  apply mul_pos h2 h2, rw ← mul_assoc,
  rw mul_comm (1 / (complex.norm_squared z₀ - r * r)) (abs (complex.norm_squared z₀ - r * r)),
  rw ← div_eq_mul_one_div, rw abs_div_self_eq_sgn,
  rw sgn_mul_abs_eq_self, 
  apply sub_le_self, apply mul_self_nonneg,
  rw ← norm_squared_eq_norm_squared_of_conj,
  rw norm_squared_of_scale, rw [mul_comm, ← mul_assoc],
  rw [← div_eq_mul_one_div, ← div_eq_mul_one_div],
  rw div_div_eq_div_mul, rw abs_mul_abs_eq_self_mul_self,
end

lemma inverted_radius_eq_iverted_center_implies_center_eq_radius
  (z₀ : ℂ) (r : ℝ) (r_pos : r > 0)
  : |center_of_inverted_circle r z₀| = radius_of_inverted_circle r z₀
  → |z₀| = r :=
begin
  intro h, by_cases h' : |z₀| = r, assumption,
  have := eq_of_sqrt_eq _ _ h,
  have := eq_sub_implies_sub_zero _ _ this,
  have : complex.norm_squared z₀ - r * r = 0,
  apply classical.by_contradiction,
  intro h, apply inv_ne_zero h, rw inv_eq_one_div, assumption,
  have := eq_of_sub_eq_zero this,
  transitivity √ (r*r), apply congr_arg sqrt this,
  symmetry, apply sqrt_unique, apply mul_self_nonneg,
  apply le_of_lt, assumption, refl, apply complex.norm_squared_nonneg,
  dunfold center_of_inverted_circle,
  apply sub_nonneg_of_le,
  apply random_inversion_inequality,
  apply ne.symm, assumption, assumption
end

lemma inversion_sends_nonzero_circles_to_circles.helper
  (z z₀ : ℂ) (r : ℝ) (r_pos : r > 0) (z_not_zero : z ≠ 0) (hz : r ≠ |z₀| )
  : |z - z₀| = r ↔ |(1/z) - center_of_inverted_circle r z₀| = radius_of_inverted_circle r z₀ :=
begin
  dunfold center_of_inverted_circle radius_of_inverted_circle,
  have : |z - z₀| = r ↔ ( z₀.norm_squared - r*r)*|1/z|*|1/z| - 2 * complex.Re (z₀*(1/z)) + 1 = 0, {
    constructor; intro h,
    { have : |z - z₀|*|z - z₀| = r*r, rw h,
      transitivity complex.Re ((1 - z₀*(1/z))*complex.conj (1 - z₀*(1/z))) - r*r*( |1/z|*|1/z| ),
      { rw sub_mul, rw sub_mul,
        transitivity complex.norm_squared z₀ * |1 / z| * |1 / z| - 2 * (z₀ * (1 / z)).Re + 1 - r * r * |1 / z| * |1 / z|,
        { repeat { rw sub_eq_add_neg }, ac_refl },
        rw mul_assoc (r*r), congr,
        rw conj_sub, rw (_ : complex.conj 1 = 1),
        tactic.swap, transitivity complex.conj (complex.mk 1 0), refl, dsimp [complex.conj], rw neg_zero, refl,
        rw FOIL_sub, rw [one_mul, one_mul, mul_one],
        rw [Re_additive, Re_sub, Re_sub, sub_sub, ← Re_additive],
        transitivity 1 - 2 * (z₀ * (1 / z)).Re + complex.norm_squared z₀ * |1 / z| * |1 / z|,
        { repeat { rw sub_eq_add_neg }, ac_refl },
        congr, rw two_mul, rw Re_additive, apply congr_fun,
        apply congr_arg, apply Re_conj,
        rw ← squared_norm_eq_norm_squared,
        rw mul_right_comm ( |z₀| ), rw mul_assoc,
        rw ← norm_mul, rw squared_norm_eq_norm_squared,
        apply norm_squared_eq_mul_conj'' },
      rw ← norm_squared_eq_mul_conj'',
      rw [← h, mul_assoc, mul_left_comm _ ( |1/z| ) _, ← mul_assoc],
      rw ← norm_mul, rw sub_mul,
      rw ← div_eq_mul_one_div z, rw div_self z_not_zero,
      rw squared_norm_eq_norm_squared, apply sub_self }, 
    { have : (complex.norm_squared z₀ - r * r) * ( |1 / z| * |1 / z| ) - (2 * (z₀ * (1 / z)).Re) / ( |1 / z| * |1 / z| ) * ( |1 / z| * |1 / z| ) + 1/( |1 / z| * |1 / z| ) *  ( |1 / z| * |1 / z| ) = 0,
      rw ← mul_assoc, rw div_eq_mul_one_div _ ( |1 / z| * |1 / z| ),
      rw mul_assoc _ _ ( |1 / z| * |1 / z| ),
      rw mul_comm _ ( |1 / z| * |1 / z| ),
      rw ← div_eq_mul_one_div _ ( |1 / z| * |1 / z| ),
      rw div_self, rw mul_one, assumption,
      rw ← norm_mul, apply mt (norm_zero_implies_zero _),
      rw ← div_mul_eq_div_mul_one_div, intro h,
      apply z_not_zero, apply eq_zero_of_sqr_eq_zero,
      have := mt (@inv_ne_zero _ _ (z*z)),
      rw [classical.dne, classical.dne] at this,
      rw inv_eq_one_div at this, apply this, assumption,
      rw [← sub_mul, ← right_distrib] at this,
      have h1 : |1/z| * |1/z| ≠ 0,
      { rw ← norm_mul, apply mt (norm_zero_implies_zero _),
        intro h, have := classical.l_or_r_eq_zero_of_mul_eq_zero h,
        rw or_self at this, rw ← inv_eq_one_div at this,
        apply mt (@inv_ne_zero _ _ z), rw classical.dne, assumption,
        assumption },
      have := or.resolve_right (classical.l_or_r_eq_zero_of_mul_eq_zero this) h1,
      suffices : |z - z₀|*|z - z₀| = r*r,
      { transitivity √( |z - z₀|*|z - z₀| ), 
        apply sqrt_unique, apply mul_self_nonneg, apply complex.norm_nonneg, refl,
        transitivity √(r*r), rw this, symmetry,
        apply sqrt_unique, apply mul_self_nonneg, apply le_of_lt, assumption, refl, },
      rw complex.squared_dist, apply eq_of_sub_eq_zero,
      transitivity complex.norm_squared z₀ - r * r - 2 * (z * complex.conj z₀).Re + complex.norm_squared z,
      { repeat { rw sub_eq_add_neg }, ac_refl },
      rw ← this,
      have : ∀ q, q / ( |1 / z| * |1 / z| ) = q * complex.norm_squared z,
      { intro q, rw div_eq_mul_one_div, congr, rw ← norm_mul,
        rw ← div_mul_eq_div_mul_one_div,
        rw ← inv_eq_one_div (z*z), rw norm_inv,
        rw ← inv_eq_one_div, rw division_ring.inv_inv, 
        rw norm_mul, rw squared_norm_eq_norm_squared,
        rw norm_mul, apply division_ring.mul_ne_zero;
        apply mt (norm_zero_implies_zero _); assumption,
        apply division_ring.mul_ne_zero; assumption, },
      apply congr,
      { apply congr_arg, apply congr_arg, 
        rw this, rw mul_assoc, rw mul_comm _ (complex.norm_squared _),
        rw ← Re_of_scale (complex.norm_squared _),
        rw [Re_conj, conj_mul, conj_of_conj],
        congr, rw scalar_mul_comm_mul', rw mul_comm, congr,
        rw norm_squared_div_self, },
      { rw this, rw one_mul } } },
  generalize hw : 1/z = w, rw hw at this,
  generalize hA : complex.norm_squared z₀ - r*r = A,
  have hA' : A ≠ 0,
  { rw ← hA, apply mt eq_of_sub_eq_zero, intro h, apply hz,
    transitivity √(r*r), apply sqrt_unique, apply mul_self_nonneg,
    apply le_of_lt, assumption, refl, rw ← h },
  rw mul_assoc at this, rw hA at this,
  have : |z - z₀| = r ↔ |w| * |w| - (2 * (z₀ * w).Re)/A + 1/A = 0,
  { rw this, 
    rw (_ : |w| * |w| - 2 * (z₀ * w).Re / A + 1 / A = (A * ( |w| * |w| ) - 2 * (z₀ * w).Re + 1)/A),
    rw (_ : ((A * ( |w| * |w| ) - 2 * (z₀ * w).Re + 1) / A = 0) ↔ 
            (0 = (A * ( |w| * |w| ) - 2 * (z₀ * w).Re + 1) / A)),
    rw eq_div_iff_mul_eq _ _ hA', rw zero_mul,
    apply eq_symm_iff, apply eq_symm_iff,
    transitivity (A/A) * ( |w| * |w| ) - 2 * (z₀ * w).Re / A + 1 / A,
    rw [div_self hA', one_mul],
    rw div_eq_mul_one_div, rw div_eq_mul_one_div (_ * _),
    transitivity A * (1 / A) * ( |w| * |w| ) - 2 * (z₀ * w).Re * (1 / A) + 1 * (1 / A), rw one_mul,
    rw mul_right_comm, rw ← sub_mul, rw ← right_distrib,
    rw ← div_eq_mul_one_div },
  rw [mul_div_assoc, div_eq_mul_one_div] at this,
  rw [mul_comm _ (1/A), ← Re_of_scale] at this,
  rw (_ : complex.scalar_mul (1 / A) (z₀ * w) = complex.scalar_mul (1 / A) z₀ * w) at this,
  tactic.swap, rw mul_comm, transitivity complex.scalar_mul (1/A) (complex.mul w z₀),
  refl, rw scalar_mul_comm_mul, transitivity w * (complex.scalar_mul (1 / A) z₀), refl,
  apply mul_comm, rw ← conj_of_conj (complex.scalar_mul (1 / A) z₀) at this,
  rw squared_norm_eq_norm_squared at this,
  rw mul_comm _ w at this,
  have : |z - z₀| = r ↔ complex.norm_squared w - 2 * (w * complex.conj (complex.conj (complex.scalar_mul (1 / A) z₀))).Re  = -(1 / A),
  { transitivity (complex.norm_squared w - 2 * (w * complex.conj (complex.conj (complex.scalar_mul (1 / A) z₀))).Re  + (1 / A) = 0),
    assumption, constructor; intro h,
    apply eq_of_sub_eq_zero, rw sub_eq_add_neg, rw neg_neg, assumption,
    rw h, apply neg_add_self, },
  have h1 := complex.squared_dist w (complex.conj (complex.scalar_mul (1 / A) z₀)),
  transitivity complex.norm_squared w - 2 * (w * complex.conj (complex.conj (complex.scalar_mul (1 / A) z₀))).Re = -(1 / A), assumption,
  transitivity complex.norm_squared w - 2 * (w * complex.conj (complex.conj (complex.scalar_mul (1 / A) z₀))).Re + complex.norm_squared (complex.conj (complex.scalar_mul (1 / A) z₀)) = complex.norm_squared (complex.conj (complex.scalar_mul (1 / A) z₀)) - (1 / A),
  { constructor; intro h,
    rw h, rw [add_comm, ← sub_eq_add_neg],
    rw sub_eq_add_neg _ (1/A) at h,
    rw add_comm _ (-(1/A)) at h,
    apply add_right_cancel, assumption, },
  rw ← h1, rw squared_norm_eq_norm_squared,
  constructor; intro h,
  { apply congr_arg sqrt, assumption },
  { rw ← squared_norm_eq_norm_squared,
    rw h, apply sqrt_sq, apply sub_nonneg_of_le,
    rw ← hA,
    apply random_inversion_inequality,
    assumption', }
end

lemma inversion_sends_nonzero_circles_to_circles
  : ∀ r z₀, r ≠ |z₀| → r > 0 →
      fun.im (λ z : ℂ, 1/z) (mk_circle z₀ r)
      = mk_circle (center_of_inverted_circle r z₀)
                  (radius_of_inverted_circle r z₀) :=
begin
  intros _ _ hnon_zero hpos, funext z, apply propext,
  constructor; intro h',
  { cases h' with w hw, cases hw, 
    have : |w - z₀| = r := hw_left,
    rw inversion_sends_nonzero_circles_to_circles.helper at this,
    have h1 : z = 1/w := hw_right,
    rw ← h1 at this, exact this, assumption',
    intro h, apply hnon_zero,
    rw ← this, rw h, rw norm_sub, rw sub_zero },
  { have : |z - center_of_inverted_circle r z₀| = radius_of_inverted_circle r z₀ := h',
    have h1 : z = 1/(1/z),
    { rw div_of_div_eq_self, apply one_ne_zero,
      intro h, apply hnon_zero, rw h at this, symmetry,
      apply inverted_radius_eq_iverted_center_implies_center_eq_radius,
      assumption, rw ← this, rw norm_sub, rw sub_zero },
    rw h1 at this,
    rw ← inversion_sends_nonzero_circles_to_circles.helper at this,
    existsi 1/z, constructor, assumption,
    simp, rw division_ring.inv_inv,
    { intro hz, have h1 : 1/z = 0, rw hz, rw div_zero,
      rw [h1, norm_sub, sub_zero] at this, apply hnon_zero, symmetry, assumption },
    assumption, 
    { intro hz, rw [hz, norm_sub, div_zero, sub_zero] at this,
      apply hnon_zero, symmetry,
      apply inverted_radius_eq_iverted_center_implies_center_eq_radius,
      assumption, assumption },
    assumption }
end

lemma scale_sends_circles_to_circles
  : ∀ (r : ℝ) (z₀ c : ℂ), c ≠ 0 →
   fun.im (λ z, c * z) (mk_circle z₀ r)
   = mk_circle (c * z₀) ( |c| * r) :=
begin
  intros, funext, apply propext,
  suffices : (∃w, |w - z₀| = r ∧ b = c*w) ↔ |b - c*z₀| = |c|*r, exact this,
  constructor; intro h,
  { cases h with w h, cases h with hdist hb,
    rw hb, rw ← mul_sub, rw norm_mul, rw hdist },
  { existsi (b/c), constructor,
    { rw (_ : z₀ = (z₀*c)/c), rw div_sub_div_same,
    rw div_eq_mul_one_div, rw norm_mul,
    rw ← inv_eq_one_div, rw norm_inv, rw inv_eq_one_div,
    rw ←  div_eq_mul_one_div, apply mul_eq_of_eq_div,
    apply inv_ne_zero, apply mt (norm_zero_implies_zero _),
    assumption,
    rw inv_eq_one_div, rw div_eq_mul_one_div,
    rw div_of_div_eq_self, rw [mul_comm, mul_comm r],
    assumption, apply one_ne_zero,
    apply mt (norm_zero_implies_zero _), assumption,
    assumption, rw mul_div_cancel, assumption },
    rw mul_comm, rw div_mul_cancel, assumption },
end

theorem problem17
  : ∀ (ρ : ℝ), ρ > 0 → ρ ≠ 1
  → ∀ (z₀ z₁ : ℂ),
    z₀ ≠ z₁ → is_circle ({ z : ℂ | |z - z₀| = ρ * |z - z₁|}) :=
begin
  intros ρ h0 h1 z₀ z₁ hz,
  have : {z : ℂ | |z - z₀| = ρ * |z - z₁|} = {z : ℂ | |z - z₀|/|z - z₁| = ρ },
  { funext, apply propext, suffices : |z - z₀| = ρ * |z - z₁| ↔ |z - z₀|/|z - z₁| = ρ, exact this,
    constructor; intro h,
    { have : z - z₁ ≠ 0,
      { intro hz0, rw [hz0, norm_of_zero, mul_zero] at h,
        apply hz, transitivity z, 
        apply eq_of_sub_eq_zero, apply neg_inj, rw neg_zero,
        rw neg_sub, apply norm_zero_implies_zero, assumption,
        apply eq_of_sub_eq_zero, assumption, },
      symmetry, rw eq_div_iff_mul_eq, symmetry, assumption,
      exact mt (norm_zero_implies_zero _) this },
    { symmetry, rw ← eq_div_iff_mul_eq, symmetry, assumption,
      intro hz, rw [hz, div_zero] at h, 
      apply ne_of_gt h0, symmetry, assumption } },
  rw this,
  have : {z : ℂ | |z - z₀|/|z - z₁| = ρ } = {z : ℂ | |(z - z₀)/(z - z₁)| = ρ },
  { funext, apply propext, suffices : |z - z₀|/|z - z₁| = ρ ↔ |(z - z₀)/(z - z₁)| = ρ, exact this,
    constructor; intro h,
    { rw norm_div, exact h, intro hz, rw hz at h,
      rw [norm_of_zero, div_zero] at h, rw h at h0,
      apply lt_irrefl ρ, exact h0 },
    { rw ← norm_div, exact h, intro hz, rw hz at h,
      rw [div_zero, norm_of_zero] at h, rw h at h0,
      apply lt_irrefl ρ, exact h0 } },
  rw this,
  have h1 : ∀ z, z - z₁ ≠ 0 → 1 + (z₁ - z₀) / (z - z₁) = (z - z₀) / (z - z₁),
  { intros z hz, rw ← div_self hz, rw [div_add_div_same, ← add_sub_assoc, sub_add_cancel] },
  have : {z : ℂ | |(z - z₀)/(z - z₁)| = ρ } = {z : ℂ | |1 + (z₁ - z₀)/(z - z₁)| = ρ },
  { funext, apply propext, suffices : |(z - z₀)/(z - z₁)| = ρ ↔ |1 + (z₁ - z₀) / (z - z₁)| = ρ,
    exact this, constructor; intro h,
    { rw h1, exact h, intro hz, rw hz at h,
      rw [div_zero, norm_of_zero] at h, rw h at h0,
      apply lt_irrefl ρ, exact h0 },
    { rw ← h1, exact h, intro hz, rw hz at h,
      rw [div_zero, add_zero, norm_of_one] at h, 
      refine ((_ : ρ ≠ 1) (eq.symm h)), assumption } },
  rw this,
  let f := λ z, 1 + (z₁ - z₀)/(z - z₁),
  let g := λ z, (z₁ - z₀)/(z - 1) + z₁,
  have gf_id : ∀ z, f (g z) = z,
  { intros z, dsimp [f, g],
    by_cases z = 1, { rw h, simp, rw [div_zero, div_zero, add_zero] },
    rw [add_assoc, add_neg_self, add_zero],
    rw [← sub_eq_add_neg, div_of_div_eq_self],
    rw [add_comm, add_assoc, neg_add_self, add_zero],
    apply mt eq_of_sub_eq_zero, apply ne.symm, assumption,
    rw ← sub_eq_add_neg, apply mt eq_of_sub_eq_zero, assumption },
  have fg_id : ∀ z, g (f z) = z,
  { intros z, dsimp [f, g],
    by_cases z = z₁, { rw h, simp, rw [div_zero, div_zero, add_zero] },
    rw [add_right_comm, add_neg_self, zero_add],
    rw [← sub_eq_add_neg, div_of_div_eq_self],
    rw [add_assoc, neg_add_self, add_zero],
    apply mt eq_of_sub_eq_zero, apply ne.symm, assumption,
    rw ← sub_eq_add_neg, intro hz, apply h, apply eq_of_sub_eq_zero hz },
  have : {z : ℂ | |1 + (z₁ - z₀)/(z - z₁)| = ρ } = {z : ℂ | |f z| = ρ }, refl,
  rw this,
  have : {z : ℂ | |f z| = ρ } = fun.pre_im f (mk_circle 0 ρ),
  { funext, apply propext, transitivity |f z| = ρ, refl,
    transitivity |f z - 0| = ρ, rw sub_zero, refl },
  rw this, clear this, clear this, clear this, clear this,
  rw fun.pre_im_of_inv_eq_im f g _ gf_id fg_id,
  let T0 : ℂ → ℂ := λ z, z - 1,
  let T1 : ℂ → ℂ := λ z, 1/z,
  let T2 : ℂ → ℂ := λ z, (z₁ - z₀) * z,
  let T3 : ℂ → ℂ := λ z, z - -z₁,
  have : g = T3 ∘ T2 ∘ T1 ∘ T0,
  { funext, simp [T0, T1, T2, T3, g, (/)],
    delta algebra.div, rw one_mul },
  rw this, clear this,
  rw [im_of_comp, im_of_comp], rw im_of_comp T0 T1,
  rw shift_sends_circles_to_circles, simp,
  rw inversion_sends_nonzero_circles_to_circles,
  rw scale_sends_circles_to_circles, 
  rw shift_sends_circles_to_circles,
  existsi ((z₁ - z₀) * center_of_inverted_circle ρ (-1) - -z₁),
  existsi ( |z₁ - z₀| * radius_of_inverted_circle ρ (-1)),
  refl,
  apply mt eq_of_sub_eq_zero, apply ne.symm, assumption,
  rw norm_neg, rw norm_of_one, assumption,
  assumption
end